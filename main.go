package main

import (
	"fmt"
	"regexp"

	"github.com/alextanhongpin/pkg/gen"
	"github.com/dave/jennifer/jen"
	. "github.com/dave/jennifer/jen"
)

var (
	tagRe *regexp.Regexp
)

func init() {
	tagRe = regexp.MustCompile(`build:"-"`)
}

func skipBuild(tag string) bool {
	return tagRe.MatchString(tag)
}

// Generator is the name of this tool.
const Generator = "builder"

func main() {
	if err := gen.New(generateStructFromFields); err != nil {
		panic(err)
	}
}

func generateBuilderName(structName string) string {
	builderName := fmt.Sprintf("%sBuilder", structName)
	return builderName
}

func generateStructFromFields(opt gen.Option) error {
	var (
		pkgName    = opt.PkgName
		pkgPath    = opt.PkgPath
		structName = opt.StructName
		fields     = opt.Fields
		out        = opt.Out
	)

	f := NewFile(pkgName) // e.g. main
	f.PackageComment(fmt.Sprintf("Code generated by %s, DO NOT EDIT.", Generator))

	var validFields []gen.StructField
	for _, field := range fields {
		if skipBuild(field.Tag) {
			continue
		}
		validFields = append(validFields, field)
	}

	generateBuilder(f, structName)
	generateBuilderConstructor(f, structName, validFields)

	for i, field := range validFields {
		if field.IsPointer {
			generateWitherPointer(f, pkgPath, structName, field, i)
		} else {
			generateWither(f, pkgPath, structName, field, i)
		}
	}

	generateBuildFunc(f, structName)
	generateBuildPartialFunc(f, structName)
	generateMustSetFunc(f, structName)
	generateIsSetFunc(f, structName)
	generateIndexOfFunc(f, structName)

	return f.Save(out) // e.g. main_gen.go
}

func generateBuilder(f *jen.File, structName string) {
	// Output:
	//type FooBuilder struct {
	//  foo Foo
	//  fields []string
	//  fieldsSet uint64
	//}

	f.Type().Id(generateBuilderName(structName)).Struct(
		Id(gen.LowerFirst(structName)).Id(structName),
		Id("fields").Index().String(),
		Id("fieldsSet").Uint64(),
	).Line()
}

func generateBuilderConstructor(f *jen.File, structName string, fields []gen.StructField) {
	// Output:
	// func NewFooBuilder(additionalFields ...string) *FooBuilder {
	//   for _, s := range additionalFields {
	//     if s == "" {
	//       panic(`builder: "" in constructor`)
	//     }
	//   }
	//   exists := make(map[string]bool)
	//   fields := append([]string{"name"}, additionalFields...)
	//     for _, field := range fields {
	//     if exists[field] {
	//       panic(fmt.Sprintf("builder: duplicate field %q", field))
	//     }
	//     exists[field] = true
	//   }
	//   return &FooBuilder{
	//     fields: fields,
	//   }
	// }

	values := make([]Code, len(fields))
	for i, field := range fields {
		values[i] = Lit(field.Name)
	}

	builderName := generateBuilderName(structName)
	f.Func().Id(fmt.Sprintf("New%s", builderName)).Params(Id("additionalFields").Op("...").String()).Op("*").Id(builderName).Block(
		For(List(Id("_"), Id("field")).Op(":=").Range().Id("additionalFields")).Block(
			If(Id("field").Op("==").Lit("")).Block(
				Panic(Lit(`builder: empty string in constructor`)),
			),
		),
		Id("exists").Op(":=").Make(Map(String()).Bool()),
		Id("fields").Op(":=").Append(Index().String().Values(values...), Id("additionalFields").Op("...")),
		For(List(Id("_"), Id("field")).Op(":=").Range().Id("fields")).Block(
			If(Id("exists").Index(Id("field"))).Block(
				Panic(Qual("fmt", "Sprintf").Call(Lit("builder: duplicate field %q"), Id("field"))),
			),
			Id("exists").Index(Id("field")).Op("=").Lit(true),
		),
		Return(Op("&").Id(builderName).Values(Dict{
			Id("fields"): Id("fields"),
		})),
	).Line()
}

func generateWither(f *jen.File, pkgPath, structName string, field gen.StructField, pos int) {
	// Output:
	// WithName sets name.
	// func (b FooBuilder) WithName(name string) FooBuilder {
	//   b.mustSet("name")
	// 	 b.foo.name = name
	//   return b
	// }

	builderName := generateBuilderName(structName)
	shortName := "b"
	funcName := fmt.Sprintf("With%s", gen.UpperCommonInitialism(field.Name))

	f.Comment(fmt.Sprintf("%s sets %s.", funcName, field.Name))
	f.Func().Params(
		Id(shortName).Id(builderName), // (b *FooBuilder)
	).Id(funcName). // WithName
			Params(Id(gen.LowerFirst(field.Name)).Add(generateType(pkgPath, field.Field, nil))). // name string
			Id(builderName).                                                                     // Return type: FooBuilder
			Block(
			Id("b").Dot("mustSet").Call(Lit(gen.LowerFirst(field.Name))),
			Id(shortName).Dot(gen.LowerFirst(structName)).Dot(field.Name).Op("=").Id(gen.LowerFirst(field.Name)),
			Return(Id(shortName)),
		).Line()
}

func generateWitherPointer(f *jen.File, pkgPath, structName string, field gen.StructField, pos int) {
	// Output:
	// WithName sets name.
	// func (b FooBuilder) WithName(name string, valid bool) FooBuilder {
	//   b.mustSet("name")
	//   if valid {
	//     b.foo.name = name
	//   }
	//   return b
	// }

	builderName := generateBuilderName(structName)
	shortName := "b"
	// Avoid conflict in naming if the variable is already named "valid".
	validVar := "valid"
	if field.Name == validVar {
		validVar += "1"
	}

	ptr := "&"
	// Disable pointer for collection pointer.
	if field.Field.IsCollection && field.Field.IsPointer {
		ptr = ""
	}

	funcName := fmt.Sprintf("With%s", gen.UpperCommonInitialism(field.Name))
	f.Comment(fmt.Sprintf("%s sets %s.", funcName, field.Name))
	f.Func().Params(
		Id(shortName).Id(builderName), // (b *FooBuilder)
	).Id(funcName). // WithName
			Params(
			// name string
			Id(gen.LowerFirst(field.Name)).Add(generateType(pkgPath, field.Field, nil)), // name string
			Id(validVar).Bool(),
		).
		Id(builderName). // Return type: FooBuilder
		Block(
			Id("b").Dot("mustSet").Call(Lit(gen.LowerFirst(field.Name))),
			If(Id(validVar)).Block(
				Id(shortName).Dot(gen.LowerFirst(structName)).Dot(field.Name).Op("=").Op(ptr).Id(gen.LowerFirst(field.Name)),
			),
			Return(Id(shortName)),
		).Line()
}

func generateBuildFunc(f *jen.File, structName string) {
	// Output:
	// Build returns Foo.
	// func (b FooBuilder) Build() Foo {
	//   for i, field := range b.fields {
	//     if !b.isSet(i) {
	//       panic(fmt.Sprintf("builder: %q not set", field)
	//     }
	//   }
	//   return b.foo
	// }

	builderName := generateBuilderName(structName)
	shortName := "b"
	f.Comment(fmt.Sprintf("Build returns %s.", structName))
	f.Func().Params(
		Id(shortName).Id(builderName), // (b *FooBuilder)
	).Id("Build").Params(). // Build()
				Id(structName). // Return type: Foo
				Block(
			For(
				List(Id("i"), Id("field")).Op(":=").Range().Id("b").Dot("fields"),
			).Block(
				If(Op("!").Id("b").Dot("isSet").Call(Id("i"))).Block(
					Panic(Qual("fmt", "Sprintf").Call(Lit("builder: %q not set"), Id("field"))),
				),
			),
			Return(Id(shortName).Dot(gen.LowerFirst(structName))),
		).Line()
}

func generateBuildPartialFunc(f *jen.File, structName string) {
	// Output:
	// Build returns Foo.
	// func (b FooBuilder) BuildPartial() Foo {
	//   return b.foo
	// }

	builderName := generateBuilderName(structName)
	shortName := "b"
	f.Comment(fmt.Sprintf("Build returns %s.", structName))
	f.Func().Params(
		Id(shortName).Id(builderName), // (b FooBuilder)
	).Id("BuildPartial").Params(). // Build()
					Id(structName). // Return type: Foo
					Block(
			Return(Id(shortName).Dot(gen.LowerFirst(structName))),
		).Line()
}

func generateMustSetFunc(f *jen.File, structName string) {
	// Output:
	// func (b *FooBuilder) mustSet(field string) {
	//   i := b.indexOf(field)
	//   if b.isSet(i) {
	//     panic(fmt.Sprintf("builder: set %q twice", field))
	//   }
	//   b.fieldsSet |= 1 << i
	// }

	builderName := generateBuilderName(structName)
	shortName := "b"
	f.Func().Params(
		Id(shortName).Op("*").Id(builderName), // (b FooBuilder)
	).Id("mustSet").Params(Id("field").String()). // mustSet(field string)
							Block(
			Id("i").Op(":=").Id("b").Dot("indexOf").Call(Id("field")),
			If(Id("b").Dot("isSet").Call(Id("i"))).Block(
				Panic(Qual("fmt", "Sprintf").Call(Lit("builder: set %q twice"), Id("field"))),
			),
			Id("b").Dot("fieldsSet").Op("|=").Lit(1).Op("<<").Id("i"),
		).Line()
}

func generateIsSetFunc(f *jen.File, structName string) {
	// Output:
	// func (b SimpleBuilder) isSet(pos int) bool {
	//   return (b.fieldsSet & (1 << pos)) == (1 << pos)
	// }

	builderName := generateBuilderName(structName)
	shortName := "b"

	f.Func().Params(
		Id(shortName).Id(builderName), // (b FooBuilder)
	).Id("isSet").Params(Id("pos").Int()). // isSet(pos int)
						Bool(). // bool
						Block(
			Return(Parens(Id("b").Dot("fieldsSet").Op("&").Parens(Lit(1).Op("<<").Id("pos"))).Op("==").Parens(Lit(1).Op("<<").Id("pos"))),
		).Line()
}

func generateIndexOfFunc(f *jen.File, structName string) {
	// Output:
	// func (b FooBuilder) indexOf(field string) int {
	//   for i, f := range b.fields {
	//     if f == field {
	//       return i
	//     }
	//   }
	//  panic(fmt.Sprintf("builder: field %q not found", field))
	// }

	builderName := generateBuilderName(structName)
	shortName := "b"

	f.Func().Params(
		Id(shortName).Id(builderName), // (b FooBuilder)
	).Id("indexOf").Params(Id("field").String()). // indexOf(field string)
							Int(). // int
							Block(
			For(
				List(Id("i"), Id("f")).Op(":=").Range().Id("b").Dot("fields").Block(
					If(Id("f").Op("==").Id("field")).Block(
						Return(Id("i")),
					),
				),
			),
			Panic(Qual("fmt", "Sprintf").Call(Lit("builder: field: %q not found"), Id("field"))),
		).Line()
}

// Generate the field and type for primitive, map or collection.
func generateType(pkgPath string, field *gen.Field, parent *gen.Field) Code {
	param := Id("")
	if field.IsMap {
		key, value := field.MapKey, field.MapValue
		param = param.Map(generateType(pkgPath, key, field))
		param = param.Add(generateType(pkgPath, value, field))
		return param
	}
	if field.IsCollection {
		param = param.Index()
	}
	// At the moment, allow setter for []*Type
	isCollectionPointer := field.IsPointer && field.IsCollection
	belongsToPointerMapOrCollection := parent != nil && (parent.IsCollection || parent.IsMap) && field.IsPointer
	if belongsToPointerMapOrCollection || isCollectionPointer {
		param = param.Add(Op("*"))
	}
	param = param.Qual(gen.SkipCurrentPackagePath(pkgPath, field.PkgPath), field.Type)
	return param
}
